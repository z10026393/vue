{"remainingRequest":"D:\\编程\\vue-p\\node_modules\\babel-loader\\lib\\index.js!D:\\编程\\vue-p\\src\\assets\\js\\swipe.js","dependencies":[{"path":"D:\\编程\\vue-p\\src\\assets\\js\\swipe.js","mtime":1583638734290},{"path":"D:\\编程\\vue-p\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1583420278921},{"path":"D:\\编程\\vue-p\\node_modules\\babel-loader\\lib\\index.js","mtime":1583420313165}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\n\n/*\n * Swipe 2.0\n *\n * Brad Birdsall\n * Copyright 2013, MIT License\n *\n*/\nfunction Swipe(container, options) {\n  \"use strict\"; // utilities\n\n  var noop = function noop() {}; // simple no operation function\n\n\n  var offloadFn = function offloadFn(fn) {\n    setTimeout(fn || noop, 0);\n  }; // offload a functions execution\n  // check browser capabilities\n\n\n  var browser = {\n    addEventListener: !!window.addEventListener,\n    touch: 'ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch,\n    transitions: function (temp) {\n      var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n\n      for (var i in props) {\n        if (temp.style[props[i]] !== undefined) return true;\n      }\n\n      return false;\n    }(document.createElement('swipe'))\n  }; // quit if no root element\n\n  if (!container) return;\n  var element = container.children[0];\n  var slides, slidePos, width, length;\n  options = options || {};\n  var index = parseInt(options.startSlide, 10) || 0;\n  var speed = options.speed || 300;\n  options.continuous = options.continuous !== undefined ? options.continuous : true;\n\n  function _setup() {\n    // cache slides\n    slides = element.children;\n    length = slides.length; // set continuous to false if only one slide\n\n    if (slides.length < 2) options.continuous = false; //special case if two slides\n\n    if (browser.transitions && options.continuous && slides.length < 3) {\n      element.appendChild(slides[0].cloneNode(true));\n      element.appendChild(element.children[1].cloneNode(true));\n      slides = element.children;\n    } // create an array to store current positions of each slide\n\n\n    slidePos = new Array(slides.length); // determine width of each slide\n    //alert(container.offsetWidth);\n\n    width = container.getBoundingClientRect().width || container.offsetWidth; //alert(width);\n    //width=document.documentElement.clientWidth;\n\n    element.style.width = slides.length * width + 'px'; // stack elements\n\n    var pos = slides.length;\n\n    while (pos--) {\n      var slide = slides[pos];\n      slide.style.width = width + 'px';\n      slide.setAttribute('data-index', pos);\n\n      if (browser.transitions) {\n        slide.style.left = pos * -width + 'px';\n        move(pos, index > pos ? -width : index < pos ? width : 0, 0);\n      }\n    } // reposition elements before and after index\n\n\n    if (options.continuous && browser.transitions) {\n      move(circle(index - 1), -width, 0);\n      move(circle(index + 1), width, 0);\n    }\n\n    if (!browser.transitions) element.style.left = index * -width + 'px';\n    container.style.visibility = 'visible';\n  }\n\n  function _prev() {\n    if (options.continuous) _slide(index - 1);else if (index) _slide(index - 1);\n  }\n\n  function _next() {\n    if (options.continuous) _slide(index + 1);else if (index < slides.length - 1) _slide(index + 1);\n  }\n\n  function circle(index) {\n    // a simple positive modulo using slides.length\n    return (slides.length + index % slides.length) % slides.length;\n  }\n\n  function _slide(to, slideSpeed) {\n    // do nothing if already on requested slide\n    if (index == to) return;\n\n    if (browser.transitions) {\n      var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward\n      // get the actual position of the slide\n\n      if (options.continuous) {\n        var natural_direction = direction;\n        direction = -slidePos[circle(to)] / width; // if going forward but to < index, use to = slides.length + to\n        // if going backward but to > index, use to = -slides.length + to\n\n        if (direction !== natural_direction) to = -direction * slides.length + to;\n      }\n\n      var diff = Math.abs(index - to) - 1; // move all the slides between index and to in the right direction\n\n      while (diff--) {\n        move(circle((to > index ? to : index) - diff - 1), width * direction, 0);\n      }\n\n      to = circle(to);\n      move(index, width * direction, slideSpeed || speed);\n      move(to, 0, slideSpeed || speed);\n      if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n    } else {\n      to = circle(to);\n      animate(index * -width, to * -width, slideSpeed || speed); //no fallback for a circular continuous if the browser does not accept transitions\n    }\n\n    index = to;\n    offloadFn(options.callback && options.callback(index, slides[index]));\n  }\n\n  function move(index, dist, speed) {\n    translate(index, dist, speed);\n    slidePos[index] = dist;\n  }\n\n  function translate(index, dist, speed) {\n    var slide = slides[index];\n    var style = slide && slide.style;\n    if (!style) return;\n    style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';\n    style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n    style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';\n  }\n\n  function animate(from, to, speed) {\n    // if not an animation, just reposition\n    if (!speed) {\n      element.style.left = to + 'px';\n      return;\n    }\n\n    var start = +new Date();\n    var timer = setInterval(function () {\n      var timeElap = +new Date() - start;\n\n      if (timeElap > speed) {\n        element.style.left = to + 'px';\n        if (delay) begin();\n        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n        clearInterval(timer);\n        return;\n      }\n\n      element.style.left = (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + 'px';\n    }, 4);\n  } // setup auto slideshow\n\n\n  var delay = options.auto || 0;\n  var interval;\n\n  function begin() {\n    interval = setTimeout(_next, delay);\n  }\n\n  function _stop() {\n    delay = 0;\n    clearTimeout(interval);\n  } // setup initial vars\n\n\n  var _start = {};\n  var delta = {};\n  var isScrolling; // setup event capturing\n\n  var events = {\n    handleEvent: function handleEvent(event) {\n      switch (event.type) {\n        case 'touchstart':\n          this.start(event);\n          break;\n\n        case 'touchmove':\n          this.move(event);\n          break;\n\n        case 'touchend':\n          offloadFn(this.end(event));\n          break;\n\n        case 'webkitTransitionEnd':\n        case 'msTransitionEnd':\n        case 'oTransitionEnd':\n        case 'otransitionend':\n        case 'transitionend':\n          offloadFn(this.transitionEnd(event));\n          break;\n\n        case 'resize':\n          offloadFn(_setup);\n          break;\n      }\n\n      if (options.stopPropagation) event.stopPropagation();\n    },\n    start: function start(event) {\n      var touches = event.touches[0]; // measure start values\n\n      _start = {\n        // get initial touch coords\n        x: touches.pageX,\n        y: touches.pageY,\n        // store time to determine touch duration\n        time: +new Date()\n      }; // used for testing first move event\n\n      isScrolling = undefined; // reset delta and end measurements\n\n      delta = {}; // attach touchmove and touchend listeners\n\n      element.addEventListener('touchmove', this, false);\n      element.addEventListener('touchend', this, false);\n    },\n    move: function move(event) {\n      // ensure swiping with one touch and not pinching\n      if (event.touches.length > 1 || event.scale && event.scale !== 1) return;\n      if (options.disableScroll) event.preventDefault();\n      var touches = event.touches[0]; // measure change in x and y\n\n      delta = {\n        x: touches.pageX - _start.x,\n        y: touches.pageY - _start.y // determine if scrolling test has run - one time test\n\n      };\n\n      if (typeof isScrolling == 'undefined') {\n        isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));\n      } // if user is not trying to scroll vertically\n\n\n      if (!isScrolling) {\n        // prevent native scrolling\n        event.preventDefault(); // stop slideshow\n\n        _stop(); // increase resistance if first or last slide\n\n\n        if (options.continuous) {\n          // we don't add resistance at the end\n          translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);\n          translate(index, delta.x + slidePos[index], 0);\n          translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);\n        } else {\n          delta.x = delta.x / (!index && delta.x > 0 // if first slide and sliding left\n          || index == slides.length - 1 // or if last slide and sliding right\n          && delta.x < 0 // and if sliding at all\n          ? Math.abs(delta.x) / width + 1 : // determine resistance level\n          1); // no resistance if false\n          // translate 1:1\n\n          translate(index - 1, delta.x + slidePos[index - 1], 0);\n          translate(index, delta.x + slidePos[index], 0);\n          translate(index + 1, delta.x + slidePos[index + 1], 0);\n        }\n      }\n    },\n    end: function end(event) {\n      // measure duration\n      var duration = +new Date() - _start.time; // determine if slide attempt triggers next/prev slide\n\n      var isValidSlide = Number(duration) < 250 // if slide duration is less than 250ms\n      && Math.abs(delta.x) > 20 // and if slide amt is greater than 20px\n      || Math.abs(delta.x) > width / 2; // or if slide amt is greater than half the width\n      // determine if slide attempt is past start and end\n\n      var isPastBounds = !index && delta.x > 0 // if first slide and slide amt is greater than 0\n      || index == slides.length - 1 && delta.x < 0; // or if last slide and slide amt is less than 0\n\n      if (options.continuous) isPastBounds = false; // determine direction of swipe (true:right, false:left)\n\n      var direction = delta.x < 0; // if not scrolling vertically\n\n      if (!isScrolling) {\n        if (isValidSlide && !isPastBounds) {\n          if (direction) {\n            if (options.continuous) {\n              // we need to get the next in this direction in place\n              move(circle(index - 1), -width, 0);\n              move(circle(index + 2), width, 0);\n            } else {\n              move(index - 1, -width, 0);\n            }\n\n            move(index, slidePos[index] - width, speed);\n            move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);\n            index = circle(index + 1);\n          } else {\n            if (options.continuous) {\n              // we need to get the next in this direction in place\n              move(circle(index + 1), width, 0);\n              move(circle(index - 2), -width, 0);\n            } else {\n              move(index + 1, width, 0);\n            }\n\n            move(index, slidePos[index] + width, speed);\n            move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);\n            index = circle(index - 1);\n          }\n\n          options.callback && options.callback(index, slides[index]);\n        } else {\n          if (options.continuous) {\n            move(circle(index - 1), -width, speed);\n            move(index, 0, speed);\n            move(circle(index + 1), width, speed);\n          } else {\n            move(index - 1, -width, speed);\n            move(index, 0, speed);\n            move(index + 1, width, speed);\n          }\n        }\n      } // kill touchmove and touchend event listeners until touchstart called again\n\n\n      element.removeEventListener('touchmove', events, false);\n      element.removeEventListener('touchend', events, false);\n    },\n    transitionEnd: function transitionEnd(event) {\n      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n        if (delay) begin();\n        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n      }\n    } // trigger setup\n\n  };\n\n  _setup(); // start auto slideshow if applicable\n\n\n  if (delay) begin(); // add event listeners\n\n  if (browser.addEventListener) {\n    // set touchstart event on element\n    if (browser.touch) element.addEventListener('touchstart', events, false);\n\n    if (browser.transitions) {\n      element.addEventListener('webkitTransitionEnd', events, false);\n      element.addEventListener('msTransitionEnd', events, false);\n      element.addEventListener('oTransitionEnd', events, false);\n      element.addEventListener('otransitionend', events, false);\n      element.addEventListener('transitionend', events, false);\n    } // set resize event on window\n\n\n    window.addEventListener('resize', events, false);\n  } else {\n    window.onresize = function () {\n      _setup();\n    }; // to play nice with old IE\n\n  } // expose the Swipe API\n\n\n  return {\n    setup: function setup() {\n      _setup();\n    },\n    slide: function slide(to, speed) {\n      // cancel slideshow\n      _stop();\n\n      _slide(to, speed);\n    },\n    prev: function prev() {\n      // cancel slideshow\n      _stop();\n\n      _prev();\n    },\n    next: function next() {\n      // cancel slideshow\n      _stop();\n\n      _next();\n    },\n    stop: function stop() {\n      // cancel slideshow\n      _stop();\n    },\n    getPos: function getPos() {\n      // return current index position\n      return index;\n    },\n    getNumSlides: function getNumSlides() {\n      // return total number of slides\n      return length;\n    },\n    kill: function kill() {\n      // cancel slideshow\n      _stop(); // reset element\n\n\n      element.style.width = '';\n      element.style.left = ''; // reset slides\n\n      var pos = slides.length;\n\n      while (pos--) {\n        var slide = slides[pos];\n        slide.style.width = '';\n        slide.style.left = '';\n        if (browser.transitions) translate(pos, 0, 0);\n      } // removed event listeners\n\n\n      if (browser.addEventListener) {\n        // remove current event listeners\n        element.removeEventListener('touchstart', events, false);\n        element.removeEventListener('webkitTransitionEnd', events, false);\n        element.removeEventListener('msTransitionEnd', events, false);\n        element.removeEventListener('oTransitionEnd', events, false);\n        element.removeEventListener('otransitionend', events, false);\n        element.removeEventListener('transitionend', events, false);\n        window.removeEventListener('resize', events, false);\n      } else {\n        window.onresize = null;\n      }\n    }\n  };\n}\n\nexport default Swipe;\n/* \nif ( window.jQuery || window.Zepto ) {\n  (function($) {\n    $.fn.Swipe = function(params) {\n      return this.each(function() {\n        $(this).data('Swipe', new Swipe($(this)[0], params));\n      });\n    }\n  })( window.jQuery || window.Zepto )\n}\n */",{"version":3,"sources":["D:\\编程\\vue-p\\src\\assets\\js\\swipe.js"],"names":["Swipe","container","options","noop","offloadFn","fn","setTimeout","browser","addEventListener","window","touch","DocumentTouch","document","transitions","temp","props","i","style","undefined","createElement","element","children","slides","slidePos","width","length","index","parseInt","startSlide","speed","continuous","setup","appendChild","cloneNode","Array","getBoundingClientRect","offsetWidth","pos","slide","setAttribute","left","move","circle","visibility","prev","next","to","slideSpeed","direction","Math","abs","natural_direction","diff","animate","callback","dist","translate","webkitTransitionDuration","MozTransitionDuration","msTransitionDuration","OTransitionDuration","transitionDuration","webkitTransform","msTransform","MozTransform","OTransform","from","start","Date","timer","setInterval","timeElap","delay","begin","transitionEnd","call","event","clearInterval","floor","auto","interval","stop","clearTimeout","delta","isScrolling","events","handleEvent","type","end","stopPropagation","touches","x","pageX","y","pageY","time","scale","disableScroll","preventDefault","duration","isValidSlide","Number","isPastBounds","removeEventListener","target","getAttribute","onresize","getPos","getNumSlides","kill"],"mappings":";;AAAA;;;;;;;AAQA,SAASA,KAAT,CAAeC,SAAf,EAA0BC,OAA1B,EAAmC;AAEjC,eAFiC,CAIjC;;AACA,MAAIC,IAAI,GAAG,SAAPA,IAAO,GAAW,CAAE,CAAxB,CALiC,CAKP;;;AAC1B,MAAIC,SAAS,GAAG,SAAZA,SAAY,CAASC,EAAT,EAAa;AAAEC,IAAAA,UAAU,CAACD,EAAE,IAAIF,IAAP,EAAa,CAAb,CAAV;AAA2B,GAA1D,CANiC,CAM2B;AAE5D;;;AACA,MAAII,OAAO,GAAG;AACZC,IAAAA,gBAAgB,EAAE,CAAC,CAACC,MAAM,CAACD,gBADf;AAEZE,IAAAA,KAAK,EAAG,kBAAkBD,MAAnB,IAA8BA,MAAM,CAACE,aAAP,IAAwBC,QAAQ,YAAYD,aAFrE;AAGZE,IAAAA,WAAW,EAAG,UAASC,IAAT,EAAe;AAC3B,UAAIC,KAAK,GAAG,CAAC,oBAAD,EAAuB,kBAAvB,EAA2C,eAA3C,EAA4D,aAA5D,EAA2E,cAA3E,CAAZ;;AACA,WAAM,IAAIC,CAAV,IAAeD,KAAf;AAAuB,YAAID,IAAI,CAACG,KAAL,CAAYF,KAAK,CAACC,CAAD,CAAjB,MAA2BE,SAA/B,EAA0C,OAAO,IAAP;AAAjE;;AACA,aAAO,KAAP;AACD,KAJY,CAIVN,QAAQ,CAACO,aAAT,CAAuB,OAAvB,CAJU;AAHD,GAAd,CATiC,CAmBjC;;AACA,MAAI,CAAClB,SAAL,EAAgB;AAChB,MAAImB,OAAO,GAAGnB,SAAS,CAACoB,QAAV,CAAmB,CAAnB,CAAd;AACA,MAAIC,MAAJ,EAAYC,QAAZ,EAAsBC,KAAtB,EAA6BC,MAA7B;AACAvB,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIwB,KAAK,GAAGC,QAAQ,CAACzB,OAAO,CAAC0B,UAAT,EAAqB,EAArB,CAAR,IAAoC,CAAhD;AACA,MAAIC,KAAK,GAAG3B,OAAO,CAAC2B,KAAR,IAAiB,GAA7B;AACA3B,EAAAA,OAAO,CAAC4B,UAAR,GAAqB5B,OAAO,CAAC4B,UAAR,KAAuBZ,SAAvB,GAAmChB,OAAO,CAAC4B,UAA3C,GAAwD,IAA7E;;AAEA,WAASC,MAAT,GAAiB;AAEf;AACAT,IAAAA,MAAM,GAAGF,OAAO,CAACC,QAAjB;AACAI,IAAAA,MAAM,GAAGH,MAAM,CAACG,MAAhB,CAJe,CAMf;;AACA,QAAIH,MAAM,CAACG,MAAP,GAAgB,CAApB,EAAuBvB,OAAO,CAAC4B,UAAR,GAAqB,KAArB,CAPR,CASf;;AACA,QAAIvB,OAAO,CAACM,WAAR,IAAuBX,OAAO,CAAC4B,UAA/B,IAA6CR,MAAM,CAACG,MAAP,GAAgB,CAAjE,EAAoE;AAClEL,MAAAA,OAAO,CAACY,WAAR,CAAoBV,MAAM,CAAC,CAAD,CAAN,CAAUW,SAAV,CAAoB,IAApB,CAApB;AACAb,MAAAA,OAAO,CAACY,WAAR,CAAoBZ,OAAO,CAACC,QAAR,CAAiB,CAAjB,EAAoBY,SAApB,CAA8B,IAA9B,CAApB;AACAX,MAAAA,MAAM,GAAGF,OAAO,CAACC,QAAjB;AACD,KAdc,CAgBf;;;AACAE,IAAAA,QAAQ,GAAG,IAAIW,KAAJ,CAAUZ,MAAM,CAACG,MAAjB,CAAX,CAjBe,CAmBf;AACA;;AACAD,IAAAA,KAAK,GAAGvB,SAAS,CAACkC,qBAAV,GAAkCX,KAAlC,IAA2CvB,SAAS,CAACmC,WAA7D,CArBe,CAsBf;AACA;;AAEAhB,IAAAA,OAAO,CAACH,KAAR,CAAcO,KAAd,GAAuBF,MAAM,CAACG,MAAP,GAAgBD,KAAjB,GAA0B,IAAhD,CAzBe,CA2Bf;;AACA,QAAIa,GAAG,GAAGf,MAAM,CAACG,MAAjB;;AACA,WAAMY,GAAG,EAAT,EAAa;AAEX,UAAIC,KAAK,GAAGhB,MAAM,CAACe,GAAD,CAAlB;AAEAC,MAAAA,KAAK,CAACrB,KAAN,CAAYO,KAAZ,GAAoBA,KAAK,GAAG,IAA5B;AACAc,MAAAA,KAAK,CAACC,YAAN,CAAmB,YAAnB,EAAiCF,GAAjC;;AAEA,UAAI9B,OAAO,CAACM,WAAZ,EAAyB;AACvByB,QAAAA,KAAK,CAACrB,KAAN,CAAYuB,IAAZ,GAAoBH,GAAG,GAAG,CAACb,KAAR,GAAiB,IAApC;AACAiB,QAAAA,IAAI,CAACJ,GAAD,EAAMX,KAAK,GAAGW,GAAR,GAAc,CAACb,KAAf,GAAwBE,KAAK,GAAGW,GAAR,GAAcb,KAAd,GAAsB,CAApD,EAAwD,CAAxD,CAAJ;AACD;AAEF,KAzCc,CA2Cf;;;AACA,QAAItB,OAAO,CAAC4B,UAAR,IAAsBvB,OAAO,CAACM,WAAlC,EAA+C;AAC7C4B,MAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkB,CAACF,KAAnB,EAA0B,CAA1B,CAAJ;AACAiB,MAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkBF,KAAlB,EAAyB,CAAzB,CAAJ;AACD;;AAED,QAAI,CAACjB,OAAO,CAACM,WAAb,EAA0BO,OAAO,CAACH,KAAR,CAAcuB,IAAd,GAAsBd,KAAK,GAAG,CAACF,KAAV,GAAmB,IAAxC;AAE1BvB,IAAAA,SAAS,CAACgB,KAAV,CAAgB0B,UAAhB,GAA6B,SAA7B;AAED;;AAED,WAASC,KAAT,GAAgB;AAEd,QAAI1C,OAAO,CAAC4B,UAAZ,EAAwBQ,MAAK,CAACZ,KAAK,GAAC,CAAP,CAAL,CAAxB,KACK,IAAIA,KAAJ,EAAWY,MAAK,CAACZ,KAAK,GAAC,CAAP,CAAL;AAEjB;;AAED,WAASmB,KAAT,GAAgB;AAEd,QAAI3C,OAAO,CAAC4B,UAAZ,EAAwBQ,MAAK,CAACZ,KAAK,GAAC,CAAP,CAAL,CAAxB,KACK,IAAIA,KAAK,GAAGJ,MAAM,CAACG,MAAP,GAAgB,CAA5B,EAA+Ba,MAAK,CAACZ,KAAK,GAAC,CAAP,CAAL;AAErC;;AAED,WAASgB,MAAT,CAAgBhB,KAAhB,EAAuB;AAErB;AACA,WAAO,CAACJ,MAAM,CAACG,MAAP,GAAiBC,KAAK,GAAGJ,MAAM,CAACG,MAAjC,IAA4CH,MAAM,CAACG,MAA1D;AAED;;AAED,WAASa,MAAT,CAAeQ,EAAf,EAAmBC,UAAnB,EAA+B;AAE7B;AACA,QAAIrB,KAAK,IAAIoB,EAAb,EAAiB;;AAEjB,QAAIvC,OAAO,CAACM,WAAZ,EAAyB;AAEvB,UAAImC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASxB,KAAK,GAACoB,EAAf,KAAsBpB,KAAK,GAACoB,EAA5B,CAAhB,CAFuB,CAE0B;AAEjD;;AACA,UAAI5C,OAAO,CAAC4B,UAAZ,EAAwB;AACtB,YAAIqB,iBAAiB,GAAGH,SAAxB;AACAA,QAAAA,SAAS,GAAG,CAACzB,QAAQ,CAACmB,MAAM,CAACI,EAAD,CAAP,CAAT,GAAwBtB,KAApC,CAFsB,CAItB;AACA;;AACA,YAAIwB,SAAS,KAAKG,iBAAlB,EAAqCL,EAAE,GAAI,CAACE,SAAD,GAAa1B,MAAM,CAACG,MAApB,GAA6BqB,EAAnC;AAEtC;;AAED,UAAIM,IAAI,GAAGH,IAAI,CAACC,GAAL,CAASxB,KAAK,GAACoB,EAAf,IAAqB,CAAhC,CAfuB,CAiBvB;;AACA,aAAOM,IAAI,EAAX;AAAeX,QAAAA,IAAI,CAAEC,MAAM,CAAC,CAACI,EAAE,GAAGpB,KAAL,GAAaoB,EAAb,GAAkBpB,KAAnB,IAA4B0B,IAA5B,GAAmC,CAApC,CAAR,EAAgD5B,KAAK,GAAGwB,SAAxD,EAAmE,CAAnE,CAAJ;AAAf;;AAEAF,MAAAA,EAAE,GAAGJ,MAAM,CAACI,EAAD,CAAX;AAEAL,MAAAA,IAAI,CAACf,KAAD,EAAQF,KAAK,GAAGwB,SAAhB,EAA2BD,UAAU,IAAIlB,KAAzC,CAAJ;AACAY,MAAAA,IAAI,CAACK,EAAD,EAAK,CAAL,EAAQC,UAAU,IAAIlB,KAAtB,CAAJ;AAEA,UAAI3B,OAAO,CAAC4B,UAAZ,EAAwBW,IAAI,CAACC,MAAM,CAACI,EAAE,GAAGE,SAAN,CAAP,EAAyB,EAAExB,KAAK,GAAGwB,SAAV,CAAzB,EAA+C,CAA/C,CAAJ,CAzBD,CAyBwD;AAEhF,KA3BD,MA2BO;AAELF,MAAAA,EAAE,GAAGJ,MAAM,CAACI,EAAD,CAAX;AACAO,MAAAA,OAAO,CAAC3B,KAAK,GAAG,CAACF,KAAV,EAAiBsB,EAAE,GAAG,CAACtB,KAAvB,EAA8BuB,UAAU,IAAIlB,KAA5C,CAAP,CAHK,CAIL;AACD;;AAEDH,IAAAA,KAAK,GAAGoB,EAAR;AACA1C,IAAAA,SAAS,CAACF,OAAO,CAACoD,QAAR,IAAoBpD,OAAO,CAACoD,QAAR,CAAiB5B,KAAjB,EAAwBJ,MAAM,CAACI,KAAD,CAA9B,CAArB,CAAT;AACD;;AAED,WAASe,IAAT,CAAcf,KAAd,EAAqB6B,IAArB,EAA2B1B,KAA3B,EAAkC;AAEhC2B,IAAAA,SAAS,CAAC9B,KAAD,EAAQ6B,IAAR,EAAc1B,KAAd,CAAT;AACAN,IAAAA,QAAQ,CAACG,KAAD,CAAR,GAAkB6B,IAAlB;AAED;;AAED,WAASC,SAAT,CAAmB9B,KAAnB,EAA0B6B,IAA1B,EAAgC1B,KAAhC,EAAuC;AAErC,QAAIS,KAAK,GAAGhB,MAAM,CAACI,KAAD,CAAlB;AACA,QAAIT,KAAK,GAAGqB,KAAK,IAAIA,KAAK,CAACrB,KAA3B;AAEA,QAAI,CAACA,KAAL,EAAY;AAEZA,IAAAA,KAAK,CAACwC,wBAAN,GACAxC,KAAK,CAACyC,qBAAN,GACAzC,KAAK,CAAC0C,oBAAN,GACA1C,KAAK,CAAC2C,mBAAN,GACA3C,KAAK,CAAC4C,kBAAN,GAA2BhC,KAAK,GAAG,IAJnC;AAMAZ,IAAAA,KAAK,CAAC6C,eAAN,GAAwB,eAAeP,IAAf,GAAsB,OAAtB,GAAgC,eAAxD;AACAtC,IAAAA,KAAK,CAAC8C,WAAN,GACA9C,KAAK,CAAC+C,YAAN,GACA/C,KAAK,CAACgD,UAAN,GAAmB,gBAAgBV,IAAhB,GAAuB,KAF1C;AAID;;AAED,WAASF,OAAT,CAAiBa,IAAjB,EAAuBpB,EAAvB,EAA2BjB,KAA3B,EAAkC;AAEhC;AACA,QAAI,CAACA,KAAL,EAAY;AAEVT,MAAAA,OAAO,CAACH,KAAR,CAAcuB,IAAd,GAAqBM,EAAE,GAAG,IAA1B;AACA;AAED;;AAED,QAAIqB,KAAK,GAAG,CAAC,IAAIC,IAAJ,EAAb;AAEA,QAAIC,KAAK,GAAGC,WAAW,CAAC,YAAW;AAEjC,UAAIC,QAAQ,GAAG,CAAC,IAAIH,IAAJ,EAAD,GAAYD,KAA3B;;AAEA,UAAII,QAAQ,GAAG1C,KAAf,EAAsB;AAEpBT,QAAAA,OAAO,CAACH,KAAR,CAAcuB,IAAd,GAAqBM,EAAE,GAAG,IAA1B;AAEA,YAAI0B,KAAJ,EAAWC,KAAK;AAEhBvE,QAAAA,OAAO,CAACwE,aAAR,IAAyBxE,OAAO,CAACwE,aAAR,CAAsBC,IAAtB,CAA2BC,KAA3B,EAAkClD,KAAlC,EAAyCJ,MAAM,CAACI,KAAD,CAA/C,CAAzB;AAEAmD,QAAAA,aAAa,CAACR,KAAD,CAAb;AACA;AAED;;AAEDjD,MAAAA,OAAO,CAACH,KAAR,CAAcuB,IAAd,GAAwB,CAACM,EAAE,GAAGoB,IAAN,KAAejB,IAAI,CAAC6B,KAAL,CAAYP,QAAQ,GAAG1C,KAAZ,GAAqB,GAAhC,IAAuC,GAAtD,CAAF,GAAiEqC,IAAlE,GAA0E,IAA/F;AAED,KAnBsB,EAmBpB,CAnBoB,CAAvB;AAqBD,GA/MgC,CAiNjC;;;AACA,MAAIM,KAAK,GAAGtE,OAAO,CAAC6E,IAAR,IAAgB,CAA5B;AACA,MAAIC,QAAJ;;AAEA,WAASP,KAAT,GAAiB;AAEfO,IAAAA,QAAQ,GAAG1E,UAAU,CAACuC,KAAD,EAAO2B,KAAP,CAArB;AAED;;AAED,WAASS,KAAT,GAAgB;AAEdT,IAAAA,KAAK,GAAG,CAAR;AACAU,IAAAA,YAAY,CAACF,QAAD,CAAZ;AAED,GAhOgC,CAmOjC;;;AACA,MAAIb,MAAK,GAAG,EAAZ;AACA,MAAIgB,KAAK,GAAG,EAAZ;AACA,MAAIC,WAAJ,CAtOiC,CAwOjC;;AACA,MAAIC,MAAM,GAAG;AAEXC,IAAAA,WAAW,EAAE,qBAASV,KAAT,EAAgB;AAE3B,cAAQA,KAAK,CAACW,IAAd;AACE,aAAK,YAAL;AAAmB,eAAKpB,KAAL,CAAWS,KAAX;AAAmB;;AACtC,aAAK,WAAL;AAAkB,eAAKnC,IAAL,CAAUmC,KAAV;AAAkB;;AACpC,aAAK,UAAL;AAAiBxE,UAAAA,SAAS,CAAC,KAAKoF,GAAL,CAASZ,KAAT,CAAD,CAAT;AAA4B;;AAC7C,aAAK,qBAAL;AACA,aAAK,iBAAL;AACA,aAAK,gBAAL;AACA,aAAK,gBAAL;AACA,aAAK,eAAL;AAAsBxE,UAAAA,SAAS,CAAC,KAAKsE,aAAL,CAAmBE,KAAnB,CAAD,CAAT;AAAsC;;AAC5D,aAAK,QAAL;AAAexE,UAAAA,SAAS,CAAC2B,MAAD,CAAT;AAAkB;AATnC;;AAYA,UAAI7B,OAAO,CAACuF,eAAZ,EAA6Bb,KAAK,CAACa,eAAN;AAE9B,KAlBU;AAmBXtB,IAAAA,KAAK,EAAE,eAASS,KAAT,EAAgB;AAErB,UAAIc,OAAO,GAAGd,KAAK,CAACc,OAAN,CAAc,CAAd,CAAd,CAFqB,CAIrB;;AACAvB,MAAAA,MAAK,GAAG;AAEN;AACAwB,QAAAA,CAAC,EAAED,OAAO,CAACE,KAHL;AAINC,QAAAA,CAAC,EAAEH,OAAO,CAACI,KAJL;AAMN;AACAC,QAAAA,IAAI,EAAE,CAAC,IAAI3B,IAAJ;AAPD,OAAR,CALqB,CAgBrB;;AACAgB,MAAAA,WAAW,GAAGlE,SAAd,CAjBqB,CAmBrB;;AACAiE,MAAAA,KAAK,GAAG,EAAR,CApBqB,CAsBrB;;AACA/D,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,WAAzB,EAAsC,IAAtC,EAA4C,KAA5C;AACAY,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,UAAzB,EAAqC,IAArC,EAA2C,KAA3C;AAED,KA7CU;AA8CXiC,IAAAA,IAAI,EAAE,cAASmC,KAAT,EAAgB;AAEpB;AACA,UAAKA,KAAK,CAACc,OAAN,CAAcjE,MAAd,GAAuB,CAAvB,IAA4BmD,KAAK,CAACoB,KAAN,IAAepB,KAAK,CAACoB,KAAN,KAAgB,CAAhE,EAAmE;AAEnE,UAAI9F,OAAO,CAAC+F,aAAZ,EAA2BrB,KAAK,CAACsB,cAAN;AAE3B,UAAIR,OAAO,GAAGd,KAAK,CAACc,OAAN,CAAc,CAAd,CAAd,CAPoB,CASpB;;AACAP,MAAAA,KAAK,GAAG;AACNQ,QAAAA,CAAC,EAAED,OAAO,CAACE,KAAR,GAAgBzB,MAAK,CAACwB,CADnB;AAENE,QAAAA,CAAC,EAAEH,OAAO,CAACI,KAAR,GAAgB3B,MAAK,CAAC0B,CAFnB,CAKR;;AALQ,OAAR;;AAMA,UAAK,OAAOT,WAAP,IAAsB,WAA3B,EAAwC;AACtCA,QAAAA,WAAW,GAAG,CAAC,EAAGA,WAAW,IAAInC,IAAI,CAACC,GAAL,CAASiC,KAAK,CAACQ,CAAf,IAAoB1C,IAAI,CAACC,GAAL,CAASiC,KAAK,CAACU,CAAf,CAAtC,CAAf;AACD,OAlBmB,CAoBpB;;;AACA,UAAI,CAACT,WAAL,EAAkB;AAEhB;AACAR,QAAAA,KAAK,CAACsB,cAAN,GAHgB,CAKhB;;AACAjB,QAAAA,KAAI,GANY,CAQhB;;;AACA,YAAI/E,OAAO,CAAC4B,UAAZ,EAAwB;AAAE;AAExB0B,UAAAA,SAAS,CAACd,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkByD,KAAK,CAACQ,CAAN,GAAUpE,QAAQ,CAACmB,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,CAApC,EAAuD,CAAvD,CAAT;AACA8B,UAAAA,SAAS,CAAC9B,KAAD,EAAQyD,KAAK,CAACQ,CAAN,GAAUpE,QAAQ,CAACG,KAAD,CAA1B,EAAmC,CAAnC,CAAT;AACA8B,UAAAA,SAAS,CAACd,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkByD,KAAK,CAACQ,CAAN,GAAUpE,QAAQ,CAACmB,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,CAApC,EAAuD,CAAvD,CAAT;AAED,SAND,MAMO;AAELyD,UAAAA,KAAK,CAACQ,CAAN,GACER,KAAK,CAACQ,CAAN,IACK,CAACjE,KAAD,IAAUyD,KAAK,CAACQ,CAAN,GAAU,CAApB,CAAoC;AAApC,aACEjE,KAAK,IAAIJ,MAAM,CAACG,MAAP,GAAgB,CAAzB,CAAkC;AAAlC,aACA0D,KAAK,CAACQ,CAAN,GAAU,CAFb,CAEqC;AAFrC,YAIA1C,IAAI,CAACC,GAAL,CAASiC,KAAK,CAACQ,CAAf,IAAoBnE,KAApB,GAA4B,CAJ5B,GAIqC;AACrC,WANJ,CADF,CAFK,CASsC;AAE3C;;AACAgC,UAAAA,SAAS,CAAC9B,KAAK,GAAC,CAAP,EAAUyD,KAAK,CAACQ,CAAN,GAAUpE,QAAQ,CAACG,KAAK,GAAC,CAAP,CAA5B,EAAuC,CAAvC,CAAT;AACA8B,UAAAA,SAAS,CAAC9B,KAAD,EAAQyD,KAAK,CAACQ,CAAN,GAAUpE,QAAQ,CAACG,KAAD,CAA1B,EAAmC,CAAnC,CAAT;AACA8B,UAAAA,SAAS,CAAC9B,KAAK,GAAC,CAAP,EAAUyD,KAAK,CAACQ,CAAN,GAAUpE,QAAQ,CAACG,KAAK,GAAC,CAAP,CAA5B,EAAuC,CAAvC,CAAT;AACD;AAEF;AAEF,KArGU;AAsGX8D,IAAAA,GAAG,EAAE,aAASZ,KAAT,EAAgB;AAEnB;AACA,UAAIuB,QAAQ,GAAG,CAAC,IAAI/B,IAAJ,EAAD,GAAYD,MAAK,CAAC4B,IAAjC,CAHmB,CAKnB;;AACA,UAAIK,YAAY,GACVC,MAAM,CAACF,QAAD,CAAN,GAAmB,GAAnB,CAAqC;AAArC,SACGlD,IAAI,CAACC,GAAL,CAASiC,KAAK,CAACQ,CAAf,IAAoB,EADvB,CACqC;AADrC,SAEG1C,IAAI,CAACC,GAAL,CAASiC,KAAK,CAACQ,CAAf,IAAoBnE,KAAK,GAAC,CAHnC,CANmB,CASwB;AAE3C;;AACA,UAAI8E,YAAY,GACV,CAAC5E,KAAD,IAAUyD,KAAK,CAACQ,CAAN,GAAU,CAApB,CAAiD;AAAjD,SACGjE,KAAK,IAAIJ,MAAM,CAACG,MAAP,GAAgB,CAAzB,IAA8B0D,KAAK,CAACQ,CAAN,GAAU,CAFjD,CAZmB,CAcoC;;AAEvD,UAAIzF,OAAO,CAAC4B,UAAZ,EAAwBwE,YAAY,GAAG,KAAf,CAhBL,CAkBnB;;AACA,UAAItD,SAAS,GAAGmC,KAAK,CAACQ,CAAN,GAAU,CAA1B,CAnBmB,CAqBnB;;AACA,UAAI,CAACP,WAAL,EAAkB;AAEhB,YAAIgB,YAAY,IAAI,CAACE,YAArB,EAAmC;AAEjC,cAAItD,SAAJ,EAAe;AAEb,gBAAI9C,OAAO,CAAC4B,UAAZ,EAAwB;AAAE;AAExBW,cAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkB,CAACF,KAAnB,EAA0B,CAA1B,CAAJ;AACAiB,cAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkBF,KAAlB,EAAyB,CAAzB,CAAJ;AAED,aALD,MAKO;AACLiB,cAAAA,IAAI,CAACf,KAAK,GAAC,CAAP,EAAU,CAACF,KAAX,EAAkB,CAAlB,CAAJ;AACD;;AAEDiB,YAAAA,IAAI,CAACf,KAAD,EAAQH,QAAQ,CAACG,KAAD,CAAR,GAAgBF,KAAxB,EAA+BK,KAA/B,CAAJ;AACAY,YAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkBH,QAAQ,CAACmB,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,CAAR,GAA0BF,KAA5C,EAAmDK,KAAnD,CAAJ;AACAH,YAAAA,KAAK,GAAGgB,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAd;AAED,WAfD,MAeO;AACL,gBAAIxB,OAAO,CAAC4B,UAAZ,EAAwB;AAAE;AAExBW,cAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkBF,KAAlB,EAAyB,CAAzB,CAAJ;AACAiB,cAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkB,CAACF,KAAnB,EAA0B,CAA1B,CAAJ;AAED,aALD,MAKO;AACLiB,cAAAA,IAAI,CAACf,KAAK,GAAC,CAAP,EAAUF,KAAV,EAAiB,CAAjB,CAAJ;AACD;;AAEDiB,YAAAA,IAAI,CAACf,KAAD,EAAQH,QAAQ,CAACG,KAAD,CAAR,GAAgBF,KAAxB,EAA+BK,KAA/B,CAAJ;AACAY,YAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkBH,QAAQ,CAACmB,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,CAAR,GAA0BF,KAA5C,EAAmDK,KAAnD,CAAJ;AACAH,YAAAA,KAAK,GAAGgB,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAd;AAED;;AAEDxB,UAAAA,OAAO,CAACoD,QAAR,IAAoBpD,OAAO,CAACoD,QAAR,CAAiB5B,KAAjB,EAAwBJ,MAAM,CAACI,KAAD,CAA9B,CAApB;AAED,SAnCD,MAmCO;AAEL,cAAIxB,OAAO,CAAC4B,UAAZ,EAAwB;AAEtBW,YAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkB,CAACF,KAAnB,EAA0BK,KAA1B,CAAJ;AACAY,YAAAA,IAAI,CAACf,KAAD,EAAQ,CAAR,EAAWG,KAAX,CAAJ;AACAY,YAAAA,IAAI,CAACC,MAAM,CAAChB,KAAK,GAAC,CAAP,CAAP,EAAkBF,KAAlB,EAAyBK,KAAzB,CAAJ;AAED,WAND,MAMO;AAELY,YAAAA,IAAI,CAACf,KAAK,GAAC,CAAP,EAAU,CAACF,KAAX,EAAkBK,KAAlB,CAAJ;AACAY,YAAAA,IAAI,CAACf,KAAD,EAAQ,CAAR,EAAWG,KAAX,CAAJ;AACAY,YAAAA,IAAI,CAACf,KAAK,GAAC,CAAP,EAAUF,KAAV,EAAiBK,KAAjB,CAAJ;AACD;AAEF;AAEF,OA5EkB,CA8EnB;;;AACAT,MAAAA,OAAO,CAACmF,mBAAR,CAA4B,WAA5B,EAAyClB,MAAzC,EAAiD,KAAjD;AACAjE,MAAAA,OAAO,CAACmF,mBAAR,CAA4B,UAA5B,EAAwClB,MAAxC,EAAgD,KAAhD;AAED,KAxLU;AAyLXX,IAAAA,aAAa,EAAE,uBAASE,KAAT,EAAgB;AAE7B,UAAIjD,QAAQ,CAACiD,KAAK,CAAC4B,MAAN,CAAaC,YAAb,CAA0B,YAA1B,CAAD,EAA0C,EAA1C,CAAR,IAAyD/E,KAA7D,EAAoE;AAElE,YAAI8C,KAAJ,EAAWC,KAAK;AAEhBvE,QAAAA,OAAO,CAACwE,aAAR,IAAyBxE,OAAO,CAACwE,aAAR,CAAsBC,IAAtB,CAA2BC,KAA3B,EAAkClD,KAAlC,EAAyCJ,MAAM,CAACI,KAAD,CAA/C,CAAzB;AAED;AAEF,KAnMU,CAuMb;;AAvMa,GAAb;;AAwMAK,EAAAA,MAAK,GAjb4B,CAmbjC;;;AACA,MAAIyC,KAAJ,EAAWC,KAAK,GApbiB,CAubjC;;AACA,MAAIlE,OAAO,CAACC,gBAAZ,EAA8B;AAE5B;AACA,QAAID,OAAO,CAACG,KAAZ,EAAmBU,OAAO,CAACZ,gBAAR,CAAyB,YAAzB,EAAuC6E,MAAvC,EAA+C,KAA/C;;AAEnB,QAAI9E,OAAO,CAACM,WAAZ,EAAyB;AACvBO,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,qBAAzB,EAAgD6E,MAAhD,EAAwD,KAAxD;AACAjE,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,iBAAzB,EAA4C6E,MAA5C,EAAoD,KAApD;AACAjE,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,gBAAzB,EAA2C6E,MAA3C,EAAmD,KAAnD;AACAjE,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,gBAAzB,EAA2C6E,MAA3C,EAAmD,KAAnD;AACAjE,MAAAA,OAAO,CAACZ,gBAAR,CAAyB,eAAzB,EAA0C6E,MAA1C,EAAkD,KAAlD;AACD,KAX2B,CAa5B;;;AACA5E,IAAAA,MAAM,CAACD,gBAAP,CAAwB,QAAxB,EAAkC6E,MAAlC,EAA0C,KAA1C;AAED,GAhBD,MAgBO;AAEL5E,IAAAA,MAAM,CAACiG,QAAP,GAAkB,YAAY;AAAE3E,MAAAA,MAAK;AAAI,KAAzC,CAFK,CAEsC;;AAE5C,GA5cgC,CA8cjC;;;AACA,SAAO;AACLA,IAAAA,KAAK,EAAE,iBAAW;AAEhBA,MAAAA,MAAK;AAEN,KALI;AAMLO,IAAAA,KAAK,EAAE,eAASQ,EAAT,EAAajB,KAAb,EAAoB;AAEzB;AACAoD,MAAAA,KAAI;;AAEJ3C,MAAAA,MAAK,CAACQ,EAAD,EAAKjB,KAAL,CAAL;AAED,KAbI;AAcLe,IAAAA,IAAI,EAAE,gBAAW;AAEf;AACAqC,MAAAA,KAAI;;AAEJrC,MAAAA,KAAI;AAEL,KArBI;AAsBLC,IAAAA,IAAI,EAAE,gBAAW;AAEf;AACAoC,MAAAA,KAAI;;AAEJpC,MAAAA,KAAI;AAEL,KA7BI;AA8BLoC,IAAAA,IAAI,EAAE,gBAAW;AAEf;AACAA,MAAAA,KAAI;AAEL,KAnCI;AAoCL0B,IAAAA,MAAM,EAAE,kBAAW;AAEjB;AACA,aAAOjF,KAAP;AAED,KAzCI;AA0CLkF,IAAAA,YAAY,EAAE,wBAAW;AAEvB;AACA,aAAOnF,MAAP;AACD,KA9CI;AA+CLoF,IAAAA,IAAI,EAAE,gBAAW;AAEf;AACA5B,MAAAA,KAAI,GAHW,CAKf;;;AACA7D,MAAAA,OAAO,CAACH,KAAR,CAAcO,KAAd,GAAsB,EAAtB;AACAJ,MAAAA,OAAO,CAACH,KAAR,CAAcuB,IAAd,GAAqB,EAArB,CAPe,CASf;;AACA,UAAIH,GAAG,GAAGf,MAAM,CAACG,MAAjB;;AACA,aAAMY,GAAG,EAAT,EAAa;AAEX,YAAIC,KAAK,GAAGhB,MAAM,CAACe,GAAD,CAAlB;AACAC,QAAAA,KAAK,CAACrB,KAAN,CAAYO,KAAZ,GAAoB,EAApB;AACAc,QAAAA,KAAK,CAACrB,KAAN,CAAYuB,IAAZ,GAAmB,EAAnB;AAEA,YAAIjC,OAAO,CAACM,WAAZ,EAAyB2C,SAAS,CAACnB,GAAD,EAAM,CAAN,EAAS,CAAT,CAAT;AAE1B,OAnBc,CAqBf;;;AACA,UAAI9B,OAAO,CAACC,gBAAZ,EAA8B;AAE5B;AACAY,QAAAA,OAAO,CAACmF,mBAAR,CAA4B,YAA5B,EAA0ClB,MAA1C,EAAkD,KAAlD;AACAjE,QAAAA,OAAO,CAACmF,mBAAR,CAA4B,qBAA5B,EAAmDlB,MAAnD,EAA2D,KAA3D;AACAjE,QAAAA,OAAO,CAACmF,mBAAR,CAA4B,iBAA5B,EAA+ClB,MAA/C,EAAuD,KAAvD;AACAjE,QAAAA,OAAO,CAACmF,mBAAR,CAA4B,gBAA5B,EAA8ClB,MAA9C,EAAsD,KAAtD;AACAjE,QAAAA,OAAO,CAACmF,mBAAR,CAA4B,gBAA5B,EAA8ClB,MAA9C,EAAsD,KAAtD;AACAjE,QAAAA,OAAO,CAACmF,mBAAR,CAA4B,eAA5B,EAA6ClB,MAA7C,EAAqD,KAArD;AACA5E,QAAAA,MAAM,CAAC8F,mBAAP,CAA2B,QAA3B,EAAqClB,MAArC,EAA6C,KAA7C;AAED,OAXD,MAYK;AAEH5E,QAAAA,MAAM,CAACiG,QAAP,GAAkB,IAAlB;AAED;AAEF;AAvFI,GAAP;AA0FD;;AAED,eAAe1G,KAAf;AACA","sourcesContent":["/*\n * Swipe 2.0\n *\n * Brad Birdsall\n * Copyright 2013, MIT License\n *\n*/\n\nfunction Swipe(container, options) {\n\n  \"use strict\";\n\n  // utilities\n  var noop = function() {}; // simple no operation function\n  var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution\n\n  // check browser capabilities\n  var browser = {\n    addEventListener: !!window.addEventListener,\n    touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,\n    transitions: (function(temp) {\n      var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n      for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;\n      return false;\n    })(document.createElement('swipe'))\n  };\n\n  // quit if no root element\n  if (!container) return;\n  var element = container.children[0];\n  var slides, slidePos, width, length;\n  options = options || {};\n  var index = parseInt(options.startSlide, 10) || 0;\n  var speed = options.speed || 300;\n  options.continuous = options.continuous !== undefined ? options.continuous : true;\n\n  function setup() {\n\n    // cache slides\n    slides = element.children;\n    length = slides.length;\n\n    // set continuous to false if only one slide\n    if (slides.length < 2) options.continuous = false;\n\n    //special case if two slides\n    if (browser.transitions && options.continuous && slides.length < 3) {\n      element.appendChild(slides[0].cloneNode(true));\n      element.appendChild(element.children[1].cloneNode(true));\n      slides = element.children;\n    }\n\n    // create an array to store current positions of each slide\n    slidePos = new Array(slides.length);\n\n    // determine width of each slide\n    //alert(container.offsetWidth);\n    width = container.getBoundingClientRect().width || container.offsetWidth;\n    //alert(width);\n    //width=document.documentElement.clientWidth;\n\n    element.style.width = (slides.length * width) + 'px';\n\n    // stack elements\n    var pos = slides.length;\n    while(pos--) {\n\n      var slide = slides[pos];\n\n      slide.style.width = width + 'px';\n      slide.setAttribute('data-index', pos);\n\n      if (browser.transitions) {\n        slide.style.left = (pos * -width) + 'px';\n        move(pos, index > pos ? -width : (index < pos ? width : 0), 0);\n      }\n\n    }\n\n    // reposition elements before and after index\n    if (options.continuous && browser.transitions) {\n      move(circle(index-1), -width, 0);\n      move(circle(index+1), width, 0);\n    }\n\n    if (!browser.transitions) element.style.left = (index * -width) + 'px';\n\n    container.style.visibility = 'visible';\n\n  }\n\n  function prev() {\n\n    if (options.continuous) slide(index-1);\n    else if (index) slide(index-1);\n\n  }\n\n  function next() {\n\n    if (options.continuous) slide(index+1);\n    else if (index < slides.length - 1) slide(index+1);\n\n  }\n\n  function circle(index) {\n\n    // a simple positive modulo using slides.length\n    return (slides.length + (index % slides.length)) % slides.length;\n\n  }\n\n  function slide(to, slideSpeed) {\n\n    // do nothing if already on requested slide\n    if (index == to) return;\n\n    if (browser.transitions) {\n\n      var direction = Math.abs(index-to) / (index-to); // 1: backward, -1: forward\n\n      // get the actual position of the slide\n      if (options.continuous) {\n        var natural_direction = direction;\n        direction = -slidePos[circle(to)] / width;\n\n        // if going forward but to < index, use to = slides.length + to\n        // if going backward but to > index, use to = -slides.length + to\n        if (direction !== natural_direction) to =  -direction * slides.length + to;\n\n      }\n\n      var diff = Math.abs(index-to) - 1;\n\n      // move all the slides between index and to in the right direction\n      while (diff--) move( circle((to > index ? to : index) - diff - 1), width * direction, 0);\n\n      to = circle(to);\n\n      move(index, width * direction, slideSpeed || speed);\n      move(to, 0, slideSpeed || speed);\n\n      if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n\n    } else {\n\n      to = circle(to);\n      animate(index * -width, to * -width, slideSpeed || speed);\n      //no fallback for a circular continuous if the browser does not accept transitions\n    }\n\n    index = to;\n    offloadFn(options.callback && options.callback(index, slides[index]));\n  }\n\n  function move(index, dist, speed) {\n\n    translate(index, dist, speed);\n    slidePos[index] = dist;\n\n  }\n\n  function translate(index, dist, speed) {\n\n    var slide = slides[index];\n    var style = slide && slide.style;\n\n    if (!style) return;\n\n    style.webkitTransitionDuration =\n    style.MozTransitionDuration =\n    style.msTransitionDuration =\n    style.OTransitionDuration =\n    style.transitionDuration = speed + 'ms';\n\n    style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n    style.msTransform =\n    style.MozTransform =\n    style.OTransform = 'translateX(' + dist + 'px)';\n\n  }\n\n  function animate(from, to, speed) {\n\n    // if not an animation, just reposition\n    if (!speed) {\n\n      element.style.left = to + 'px';\n      return;\n\n    }\n\n    var start = +new Date;\n\n    var timer = setInterval(function() {\n\n      var timeElap = +new Date - start;\n\n      if (timeElap > speed) {\n\n        element.style.left = to + 'px';\n\n        if (delay) begin();\n\n        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\n        clearInterval(timer);\n        return;\n\n      }\n\n      element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';\n\n    }, 4);\n\n  }\n\n  // setup auto slideshow\n  var delay = options.auto || 0;\n  var interval;\n\n  function begin() {\n\n    interval = setTimeout(next, delay);\n\n  }\n\n  function stop() {\n\n    delay = 0;\n    clearTimeout(interval);\n\n  }\n\n\n  // setup initial vars\n  var start = {};\n  var delta = {};\n  var isScrolling;\n\n  // setup event capturing\n  var events = {\n\n    handleEvent: function(event) {\n\n      switch (event.type) {\n        case 'touchstart': this.start(event); break;\n        case 'touchmove': this.move(event); break;\n        case 'touchend': offloadFn(this.end(event)); break;\n        case 'webkitTransitionEnd':\n        case 'msTransitionEnd':\n        case 'oTransitionEnd':\n        case 'otransitionend':\n        case 'transitionend': offloadFn(this.transitionEnd(event)); break;\n        case 'resize': offloadFn(setup); break;\n      }\n\n      if (options.stopPropagation) event.stopPropagation();\n\n    },\n    start: function(event) {\n\n      var touches = event.touches[0];\n\n      // measure start values\n      start = {\n\n        // get initial touch coords\n        x: touches.pageX,\n        y: touches.pageY,\n\n        // store time to determine touch duration\n        time: +new Date\n\n      };\n\n      // used for testing first move event\n      isScrolling = undefined;\n\n      // reset delta and end measurements\n      delta = {};\n\n      // attach touchmove and touchend listeners\n      element.addEventListener('touchmove', this, false);\n      element.addEventListener('touchend', this, false);\n\n    },\n    move: function(event) {\n\n      // ensure swiping with one touch and not pinching\n      if ( event.touches.length > 1 || event.scale && event.scale !== 1) return\n\n      if (options.disableScroll) event.preventDefault();\n\n      var touches = event.touches[0];\n\n      // measure change in x and y\n      delta = {\n        x: touches.pageX - start.x,\n        y: touches.pageY - start.y\n      }\n\n      // determine if scrolling test has run - one time test\n      if ( typeof isScrolling == 'undefined') {\n        isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );\n      }\n\n      // if user is not trying to scroll vertically\n      if (!isScrolling) {\n\n        // prevent native scrolling\n        event.preventDefault();\n\n        // stop slideshow\n        stop();\n\n        // increase resistance if first or last slide\n        if (options.continuous) { // we don't add resistance at the end\n\n          translate(circle(index-1), delta.x + slidePos[circle(index-1)], 0);\n          translate(index, delta.x + slidePos[index], 0);\n          translate(circle(index+1), delta.x + slidePos[circle(index+1)], 0);\n\n        } else {\n\n          delta.x =\n            delta.x /\n              ( (!index && delta.x > 0               // if first slide and sliding left\n                || index == slides.length - 1        // or if last slide and sliding right\n                && delta.x < 0                       // and if sliding at all\n              ) ?\n              ( Math.abs(delta.x) / width + 1 )      // determine resistance level\n              : 1 );                                 // no resistance if false\n\n          // translate 1:1\n          translate(index-1, delta.x + slidePos[index-1], 0);\n          translate(index, delta.x + slidePos[index], 0);\n          translate(index+1, delta.x + slidePos[index+1], 0);\n        }\n\n      }\n\n    },\n    end: function(event) {\n\n      // measure duration\n      var duration = +new Date - start.time;\n\n      // determine if slide attempt triggers next/prev slide\n      var isValidSlide =\n            Number(duration) < 250               // if slide duration is less than 250ms\n            && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px\n            || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width\n\n      // determine if slide attempt is past start and end\n      var isPastBounds =\n            !index && delta.x > 0                            // if first slide and slide amt is greater than 0\n            || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0\n\n      if (options.continuous) isPastBounds = false;\n\n      // determine direction of swipe (true:right, false:left)\n      var direction = delta.x < 0;\n\n      // if not scrolling vertically\n      if (!isScrolling) {\n\n        if (isValidSlide && !isPastBounds) {\n\n          if (direction) {\n\n            if (options.continuous) { // we need to get the next in this direction in place\n\n              move(circle(index-1), -width, 0);\n              move(circle(index+2), width, 0);\n\n            } else {\n              move(index-1, -width, 0);\n            }\n\n            move(index, slidePos[index]-width, speed);\n            move(circle(index+1), slidePos[circle(index+1)]-width, speed);\n            index = circle(index+1);\n\n          } else {\n            if (options.continuous) { // we need to get the next in this direction in place\n\n              move(circle(index+1), width, 0);\n              move(circle(index-2), -width, 0);\n\n            } else {\n              move(index+1, width, 0);\n            }\n\n            move(index, slidePos[index]+width, speed);\n            move(circle(index-1), slidePos[circle(index-1)]+width, speed);\n            index = circle(index-1);\n\n          }\n\n          options.callback && options.callback(index, slides[index]);\n\n        } else {\n\n          if (options.continuous) {\n\n            move(circle(index-1), -width, speed);\n            move(index, 0, speed);\n            move(circle(index+1), width, speed);\n\n          } else {\n\n            move(index-1, -width, speed);\n            move(index, 0, speed);\n            move(index+1, width, speed);\n          }\n\n        }\n\n      }\n\n      // kill touchmove and touchend event listeners until touchstart called again\n      element.removeEventListener('touchmove', events, false)\n      element.removeEventListener('touchend', events, false)\n\n    },\n    transitionEnd: function(event) {\n\n      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n\n        if (delay) begin();\n\n        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\n      }\n\n    }\n\n  }\n\n  // trigger setup\n  setup();\n\n  // start auto slideshow if applicable\n  if (delay) begin();\n\n\n  // add event listeners\n  if (browser.addEventListener) {\n\n    // set touchstart event on element\n    if (browser.touch) element.addEventListener('touchstart', events, false);\n\n    if (browser.transitions) {\n      element.addEventListener('webkitTransitionEnd', events, false);\n      element.addEventListener('msTransitionEnd', events, false);\n      element.addEventListener('oTransitionEnd', events, false);\n      element.addEventListener('otransitionend', events, false);\n      element.addEventListener('transitionend', events, false);\n    }\n\n    // set resize event on window\n    window.addEventListener('resize', events, false);\n\n  } else {\n\n    window.onresize = function () { setup() }; // to play nice with old IE\n\n  }\n\n  // expose the Swipe API\n  return {\n    setup: function() {\n\n      setup();\n\n    },\n    slide: function(to, speed) {\n\n      // cancel slideshow\n      stop();\n\n      slide(to, speed);\n\n    },\n    prev: function() {\n\n      // cancel slideshow\n      stop();\n\n      prev();\n\n    },\n    next: function() {\n\n      // cancel slideshow\n      stop();\n\n      next();\n\n    },\n    stop: function() {\n\n      // cancel slideshow\n      stop();\n\n    },\n    getPos: function() {\n\n      // return current index position\n      return index;\n\n    },\n    getNumSlides: function() {\n\n      // return total number of slides\n      return length;\n    },\n    kill: function() {\n\n      // cancel slideshow\n      stop();\n\n      // reset element\n      element.style.width = '';\n      element.style.left = '';\n\n      // reset slides\n      var pos = slides.length;\n      while(pos--) {\n\n        var slide = slides[pos];\n        slide.style.width = '';\n        slide.style.left = '';\n\n        if (browser.transitions) translate(pos, 0, 0);\n\n      }\n\n      // removed event listeners\n      if (browser.addEventListener) {\n\n        // remove current event listeners\n        element.removeEventListener('touchstart', events, false);\n        element.removeEventListener('webkitTransitionEnd', events, false);\n        element.removeEventListener('msTransitionEnd', events, false);\n        element.removeEventListener('oTransitionEnd', events, false);\n        element.removeEventListener('otransitionend', events, false);\n        element.removeEventListener('transitionend', events, false);\n        window.removeEventListener('resize', events, false);\n\n      }\n      else {\n\n        window.onresize = null;\n\n      }\n\n    }\n  }\n\n}\n\r\nexport default Swipe;\n/* \nif ( window.jQuery || window.Zepto ) {\n  (function($) {\n    $.fn.Swipe = function(params) {\n      return this.each(function() {\n        $(this).data('Swipe', new Swipe($(this)[0], params));\n      });\n    }\n  })( window.jQuery || window.Zepto )\n}\n */"]}]}