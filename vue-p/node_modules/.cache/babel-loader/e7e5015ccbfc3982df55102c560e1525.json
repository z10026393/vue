{"remainingRequest":"D:\\编程\\vue-p\\node_modules\\thread-loader\\dist\\cjs.js!D:\\编程\\vue-p\\node_modules\\babel-loader\\lib\\index.js!D:\\编程\\vue-p\\src\\plugins\\axios.js","dependencies":[{"path":"D:\\编程\\vue-p\\src\\plugins\\axios.js","mtime":1584544304548},{"path":"D:\\编程\\vue-p\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1583420278921},{"path":"D:\\编程\\vue-p\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1583420272741},{"path":"D:\\编程\\vue-p\\node_modules\\babel-loader\\lib\\index.js","mtime":1583420313165}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport axios from 'axios';\nimport Vue from 'vue';\nimport router from \"./router.js\"; // {currentRoute,push,replace} -> currentRoute=={key:value,fullPath}\n\nimport store from \"./store.js\"; //添加一个请求的拦截器\n\naxios.interceptors.request.use(function (config) {\n  // console.log('请求时拦截器');\n  //config 含有发出的请求的配置信息  axios(config)\n  // 请求发出之前做点事  请求体里面 每次都自动携带token本地读取\n  // let token = window.localStorage.getItem('user')\n  // token = token ? JSON.parse(window.localStorage.getItem('user')).token : '',\n  var token = store.state.user.user.token;\n  token = token ? token : '', config.headers = {\n    token: token //控制loading显示\n\n  };\n  store.commit('UPDATE_LOADING', true);\n  return config; // 撒手放出经过配置的请求\n}, function (error) {\n  // 发出了错误的请求，拦截\n  return Promise.reject(error);\n}); // 添加一个响应的拦截器\n\naxios.interceptors.response.use(function (response) {\n  // console.log('响应时拦截器',response.data.err);\n  //response  ~~ axios请求后的res\n  //控制loading显示\n  store.commit('UPDATE_LOADING', false); // 响应数据回来后，到达目标组件之前，做点事   res.status   res.data.err == 2\n  //校验返回数据，token过期，路由跳转login,传递当前路由地址\n\n  var currentRoute = router.currentRoute.fullPath; //获取当前路由全路径，string\n\n  if (response.data.err === 2 && !currentRoute.includes('/login')) {\n    router.replace({\n      path: '/login',\n      query: {\n        p: currentRoute\n      }\n    });\n  }\n\n  return response; //奔向组件\n}, function (error) {\n  // 错误的响应，拦截\n  return Promise.reject(error);\n});\nVue.prototype.$axios = axios;\nwindow.axios = axios;\nexport default axios;",{"version":3,"sources":["D:\\编程\\vue-p\\src\\plugins\\axios.js"],"names":["axios","Vue","router","store","interceptors","request","use","config","token","state","user","headers","commit","error","Promise","reject","response","currentRoute","fullPath","data","err","includes","replace","path","query","p","prototype","$axios","window"],"mappings":";;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,GAAP,MAAgB,KAAhB;AACA,OAAOC,MAAP,oB,CAAgC;;AAChC,OAAOC,KAAP,mB,CACA;;AACAH,KAAK,CAACI,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CAA+B,UAASC,MAAT,EAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAIC,KAAK,GAAGL,KAAK,CAACM,KAAN,CAAYC,IAAZ,CAAiBA,IAAjB,CAAsBF,KAAlC;AACAA,EAAAA,KAAK,GAAGA,KAAK,GAAGA,KAAH,GAAW,EAAxB,EACAD,MAAM,CAACI,OAAP,GAAe;AACbH,IAAAA,KAAK,EAAEA,KADM,CAIf;;AAJe,GADf;AAMAL,EAAAA,KAAK,CAACS,MAAN,CAAa,gBAAb,EAA8B,IAA9B;AACA,SAAOL,MAAP,CAd8C,CAchC;AACf,CAfD,EAeG,UAASM,KAAT,EAAgB;AACjB;AACA,SAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACD,CAlBD,E,CAoBA;;AACAb,KAAK,CAACI,YAAN,CAAmBY,QAAnB,CAA4BV,GAA5B,CAAgC,UAASU,QAAT,EAAmB;AACjD;AACA;AAEA;AACAb,EAAAA,KAAK,CAACS,MAAN,CAAa,gBAAb,EAA8B,KAA9B,EALiD,CAQjD;AAEA;;AACA,MAAIK,YAAY,GAAGf,MAAM,CAACe,YAAP,CAAoBC,QAAvC,CAXiD,CAWD;;AAChD,MAAGF,QAAQ,CAACG,IAAT,CAAcC,GAAd,KAAoB,CAApB,IAAyB,CAACH,YAAY,CAACI,QAAb,CAAsB,QAAtB,CAA7B,EAA6D;AAC3DnB,IAAAA,MAAM,CAACoB,OAAP,CAAe;AACbC,MAAAA,IAAI,EAAC,QADQ;AAEbC,MAAAA,KAAK,EAAC;AAACC,QAAAA,CAAC,EAACR;AAAH;AAFO,KAAf;AAID;;AAED,SAAOD,QAAP,CAnBiD,CAmBjC;AACjB,CApBD,EAoBG,UAASH,KAAT,EAAgB;AACjB;AACA,SAAOC,OAAO,CAACC,MAAR,CAAeF,KAAf,CAAP;AACD,CAvBD;AA0BAZ,GAAG,CAACyB,SAAJ,CAAcC,MAAd,GAAqB3B,KAArB;AACA4B,MAAM,CAAC5B,KAAP,GAAaA,KAAb;AACA,eAAeA,KAAf","sourcesContent":["import axios from 'axios';\r\nimport Vue from 'vue';\r\nimport router from './router.js'// {currentRoute,push,replace} -> currentRoute=={key:value,fullPath}\r\nimport store from './store.js';\r\n//添加一个请求的拦截器\r\naxios.interceptors.request.use(function(config) {\r\n  // console.log('请求时拦截器');\r\n  //config 含有发出的请求的配置信息  axios(config)\r\n  // 请求发出之前做点事  请求体里面 每次都自动携带token本地读取\r\n  // let token = window.localStorage.getItem('user')\r\n  // token = token ? JSON.parse(window.localStorage.getItem('user')).token : '',\r\n  let token = store.state.user.user.token;\r\n  token = token ? token : '',\r\n  config.headers={\r\n    token: token\r\n  }\r\n  \r\n  //控制loading显示\r\n  store.commit('UPDATE_LOADING',true)\r\n  return config;// 撒手放出经过配置的请求\r\n}, function(error) {\r\n  // 发出了错误的请求，拦截\r\n  return Promise.reject(error);\r\n});\r\n\r\n// 添加一个响应的拦截器\r\naxios.interceptors.response.use(function(response) {\r\n  // console.log('响应时拦截器',response.data.err);\r\n  //response  ~~ axios请求后的res\r\n  \r\n  //控制loading显示\r\n  store.commit('UPDATE_LOADING',false)\r\n  \r\n  \r\n  // 响应数据回来后，到达目标组件之前，做点事   res.status   res.data.err == 2\r\n  \r\n  //校验返回数据，token过期，路由跳转login,传递当前路由地址\r\n  let currentRoute = router.currentRoute.fullPath;//获取当前路由全路径，string\r\n  if(response.data.err===2 && !currentRoute.includes('/login')){\r\n    router.replace({\r\n      path:'/login',\r\n      query:{p:currentRoute}\r\n    })\r\n  }\r\n  \r\n  return response;//奔向组件\r\n}, function(error) {\r\n  // 错误的响应，拦截\r\n  return Promise.reject(error);\r\n});\n\r\n\r\nVue.prototype.$axios=axios;\r\nwindow.axios=axios;\r\nexport default axios;"]}]}